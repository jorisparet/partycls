<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>partycls.descriptor.descriptor API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
<style>.homelink{display:block}.homelink img{max-width:150px;margin-left:auto;margin-right:auto;margin-bottom:.3em}</style>
<link rel="shortcut icon" href="https://raw.githubusercontent.com/jorisparet/partycls/jupyter-book/logo/favicon.svg"/>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>partycls.descriptor.descriptor</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy
from partycls.trajectory import Trajectory
from partycls.core.utils import standardize_condition
from .realspace_wrap import compute
from partycls.particle import aliases


class StructuralDescriptor:
    &#34;&#34;&#34;
    Base class for structural descriptors.
    
    The descriptor is calculated for the provided trajectory `trajectory`. This can be:
    - an object implementing the `Trajectory` interface ;
    - the path to a trajectory file in a format recognized by partyclsl ;
    
    A structural descriptor S(x) is a collection of N individual empirical correlation 
    functions {s_i(x)} at the particle level, defined over a grid {x_j} of M features.
    These are stored in the `features` array as a matrix usually refered to as the &#34;data set&#34;:
    
    s_0(x_0) s_0(x_1) ... s_0(x_M)
    s_1(x_0) s_1(x_1) ... s_1(x_M)
    ...      ...          ...
    s_N(x_0) s_N(x_1) ... s_N(x_M)
    
    The `features` array is None by default and is computed only when the `compute()` method is called.
    
    The correlations can be calculated between two arbitrary subsets of particles called &#34;groups&#34;:
    - group 0 is the main group, i.e. particles for which the correlations are being calculated ;
    - group 1 is the secondary group, i.e. particles that are being considered when calculating the correlations ;
    These groups are formed by adding filters on particles&#39; properties (species, radius, position, etc.).
    
    Parameters
    ----------
    
    trajectory : str or an instance of `Trajectory`.
        Trajectory on which the structural descriptor will be computed.
    
    Attributes
    ----------
    
    trajectory : Trajectory
        Trajectory on which the structural descriptor will be computed.
        
    active_filters : list of str
        All the active filters on both groups prior to the computation of the
        descriptor.
        
    dimension : int
        Spatial dimension of the descriptor (2 or 3).
        
    grid : array
        Grid over which the structural features will be computed.
        
    features : ndarray
        Array of all the structural features for the particles in group=0 in
        accordance with the defined filters (if any). This attribute is 
        initialized when the method `compute` is called (default value is None).
        
    groups : tuple
        Composition of the groups: groups[0] and groups[1] contain lists of all
        the `Particle` objects in groups 0 and 1 respectively. Each element of 
        the tuple is a list of `Particle` in `trajectory`, e.g. groups[0][0] is 
        the list of all the particles in the first frame of `trajectory` that 
        belong to group=0.
    
    Examples:
    ---------
    
    &gt;&gt;&gt; D = StructuralDescriptor(&#39;trajectory.xyz&#39;)
    &gt;&gt;&gt; D.add_filter(&#34;species == &#39;A&#39;&#34;, group=0)
    &gt;&gt;&gt; D.add_filter(&#34;species == &#39;B&#39;&#34;, group=1)
    &gt;&gt;&gt; D.active_filters
    [(&#34;particle.species == &#39;A&#39;&#34;, 0), (&#34;particle.species == &#39;B&#39;&#34;, 1)]
    &gt;&gt;&gt; D.clear_filters(0)
    &gt;&gt;&gt; D.active_filters
    [(&#34;particle.species == &#39;B&#39;&#34;, 1)]
    &#34;&#34;&#34;

    def __init__(self, trajectory):
        # Trajectory
        # TODO: we can&#39;t change format or backend when passing a string
        if isinstance(trajectory, str):
            self.trajectory = Trajectory(trajectory)
        else:
            self.trajectory = trajectory
        # Default: consider all particles for the correlation
        self.groups = ([], [])
        self._group_init(0)
        self._group_init(1)
        # Active filters (none by default)
        self.active_filters = []
        # Dimension is guessed from the first frame of the trajectory
        self.dimension = self.trajectory[0].n_dimensions
        # Features
        #  default is None (when the object is created)
        #  correctly assigned when is method compute() is called
        self.grid = None
        self.features = None

    def __str__(self):
        rep = &#39;Descriptor(name=&#34;{}&#34;, dimension={}, filters={})&#39;
        return rep.format(self.name, self.dimension, self.active_filters)

    def __repr__(self):
        return self.__str__()

    def _group_init(self, group):
        &#34;&#34;&#34;
        Initialize the group `group` with all the particles by default.
        &#34;&#34;&#34;
        self.groups[group].clear()
        for system in self.trajectory:
            frame = []
            for particle in system.particle:
                frame.append(particle)
            self.groups[group].append(frame.copy())

    def add_filter(self, condition, group=0):
        &#34;&#34;&#34;
        Add a filter on the group (0 or 1) to select the subset of particles
        that respects the provided condition.

        Parameters
        ----------
        condition : str
            The condition should have the following format:
    
            &lt;attribute&gt; _operator_ &lt;value&gt;
            
            where:
            - &lt;attribute&gt; is a particle property (accepts aliases) ;
            - _operator_ is a logical operator (&lt;, &lt;=, ==, &gt;=, &gt;) ;
            - &lt;value&gt; is the corresponding value of &lt;attribute&gt; with the proper type ;
        
        group : int, optional
            Index of the group to which the filter must be applied.
            The default is 0.

        Returns
        -------
        None.
        
        Examples:
        ---------
        &gt;&gt;&gt; S = StructuralDescriptor(&#39;trajectory.xyz&#39;)
        &gt;&gt;&gt; S.add_filter(&#34;particle.radius &lt; 0.5&#34;)
        &gt;&gt;&gt; S.add_filter(&#34;species == &#39;A&#39;&#34;, group=1)
        &gt;&gt;&gt; S.add_filter(&#34;x &lt; 0&#34;, group=0) # particles on the left side of the box
      
        &#34;&#34;&#34;
        condition = standardize_condition(condition)
        self.active_filters.append((condition, group))
        # Iterate over frames
        for frame in self.groups[group]:
            to_remove = []
            # First find particles to remove from the current frame
            for particle in frame:
                if not(eval(condition)):
                    to_remove.append(particle)
            # Actually remove them
            for p_to_rem in to_remove:
                frame.remove(p_to_rem)
        self._sanity_checks()

    def clear_filters(self, group=0):
        &#34;&#34;&#34;
        Clear all active filters on `group`.
        All particles are included again in `group`.        

        Parameters
        ----------
        group : int, optional
            Index of the group on which to clear the filters. The default is 0.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # Reset `group` with all the particles
        self._group_init(group)
        # Update the `active_filters` list
        for fltr in self.active_filters:
            if fltr[1] == group:
                self.active_filters.remove(fltr)

    def clear_all_filters(self):
        &#34;&#34;&#34;
        Clear all active filters in both groups.
        All particles are included in both groups again.        

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self._group_init(0)
        self._group_init(1)
        self.active_filters = []

    def group_size(self, group):
        &#34;&#34;&#34;
        Return the number of particles in `group`.
        &#34;&#34;&#34;
        N = 0
        for frame in self.groups[group]:
            N += len(frame)
        return N

    def get_group_property(self, what, group):
        &#34;&#34;&#34;
        Return a list of numpy arrays with the properties of the particles in
        group `group`. The list size is the number of systems in the 
        trajectory.

        Parameters
        ----------
        what : str
            Requested particle property. 
            
            `what` must be a particle property or an alias.
            
            The following particle aliases are accepted:
            - &#39;position&#39;: &#39;particle.position&#39;
            - &#39;pos&#39;: &#39;particle.position&#39;
            - &#39;position[0]&#39;: &#39;particle.position[0]&#39;, 
            - &#39;pos[0]&#39;: &#39;particle.position[0]&#39;
            - &#39;x&#39;: &#39;particle.position[0]&#39;
            - &#39;position[1]&#39;: &#39;particle.position[1]&#39;,
            - &#39;pos[1]&#39;: &#39;particle.position[1]&#39;
            - &#39;y&#39;: &#39;particle.position[1]&#39;
            - &#39;position[2]&#39;: &#39;particle.position[2]&#39;
            - &#39;pos[2]&#39;: &#39;particle.position[2]&#39;
            - &#39;z&#39;: &#39;particle.position[2]&#39;
            - &#39;species&#39;: &#39;particle.species&#39;
            - &#39;spe&#39;: &#39;particle.species&#39;
            - &#39;label&#39;: &#39;particle.label&#39;
            - &#39;index&#39;: &#39;particle.index&#39;
            - &#39;mass&#39;: &#39;particle.mass&#39;
            - &#39;radius&#39;: &#39;particle.radius&#39;

        Returns
        -------
        to_dump : list
            List of the requested particle property with length equal to the 
            number of frames in the trajectory. Each element of the list is a
            numpy.ndarray of the requested particle property.
            
        Examples
        --------
        &gt;&gt;&gt; traj = Trajectory(&#39;trajectory.xyz&#39;)
        &gt;&gt;&gt; D = StructuralDescriptor(traj)
        &gt;&gt;&gt; D.get_group_property(&#39;position&#39;, 0)
        &gt;&gt;&gt; D.get_group_property(&#39;x&#39;, 1)
        &gt;&gt;&gt; D.get_group_property(&#39;energy&#39;, 0)
        
        &#34;&#34;&#34;
        if what in aliases:
            what = aliases[what]
        if what.startswith(&#39;particle&#39;):
            what = what.split(&#39;.&#39;)[-1]
        to_dump = []
        for frame in self.groups[group]:
            to_dump_frame = []
            for particle in frame:
                to_dump_frame.append(eval(&#39;particle.{}&#39;.format(what)))
            to_dump.append(numpy.array(to_dump_frame))
        return to_dump

    def dump(self, what, group):
        &#34;&#34;&#34;
        Alias for the method get_group_property.
        &#34;&#34;&#34;
        return self.get_group_property(what, group)

    def group_fraction(self, group):
        &#34;&#34;&#34;
        Return the fraction of particles inside `group` over the whole trajectory.
        &#34;&#34;&#34;
        N_group = self.group_size(group)
        N_tot = numpy.sum([len(sys.particle) for sys in self.trajectory])
        return N_group / N_tot

    @property
    def size(self):
        &#34;&#34;&#34;
        Total number of particles in the descriptor (i.e. in group=0).
        &#34;&#34;&#34;
        return sum([len(frame) for frame in self.groups[0]])

    @property
    def n_features(self):
        &#34;&#34;&#34;
        Number of features of the descriptor.
        &#34;&#34;&#34;
        return len(self.grid)

    @property
    def average(self):
        &#34;&#34;&#34;
        Average feature vector of the descriptor.
        &#34;&#34;&#34;
        return numpy.mean(self.features, axis=0)

    def compute(self):
        pass

    def normalize(self, dist):
        &#34;&#34;&#34;
        Generic normalization function for child classes. Returns the input
        distribution unchanged.
        &#34;&#34;&#34;
        return dist

    def _sanity_checks(self):
        assert (self.group_size(0) &gt; 0 and self.group_size(1) &gt; 0), &#39;groups cannot be empty.&#39;


class AngularStructuralDescriptor(StructuralDescriptor):
    &#34;&#34;&#34;
    Base class for angular structural descriptors.
    
    See the parent class for more details.
    
    Descriptors that exploit angular correlations and require nearest-neighbors information 
    will inherit of this class. Two methods to identify nearest-neighbors are available:
    - &#34;Fixed cutoff&#34; (symbol: &#39;FC&#39;): uses the partial radial distribution functions to compute
      the cutoffs between each possible pair of species (s1, s2) ;
    - &#34;Solid-Angle based Nearest Neighbors&#34; (symbol: &#39;SANN&#39;): see van Meel et al. (https://doi.org/10.1063/1.4729313)
    
    The nearest-neighbors method can be changed by modifying the attribute `nearest_neighbors_method`
    to &#39;FC&#39; (default) or &#39;SANN&#39;.
    
    When using the &#39;FC&#39; method, it is also possible to specify the cutoffs manually
    for a pair of species (s1, s2) by using the method `set_cutoff`. The cutoffs
    that were not set manually will be computed automatically.
    
    Parameters
    ----------
    
    trajectory : str or an instance of `Trajectory`.
        Trajectory on which the structural descriptor will be computed.
    
    Attributes
    ----------
    
    cutoffs : list of float
        List of cutoff distances to identify the nearest neighbors using
        the fixed-cutoff (&#39;FC&#39;) method.
        
    nearest_neighbors_method : str, default: &#39;FC&#39;
        Nearest neighbor method, &#39;FC&#39; or &#39;SANN&#39;.
        
    neighbors : list
        Lists of nearest neighbors for all the particles in group=0. Empty by
        default and filled when calling the method `nearest_neighbors`.
    &#34;&#34;&#34;

    def __init__(self, trajectory):
        StructuralDescriptor.__init__(self, trajectory)
        self.cutoffs = [None for n in range(len(self.trajectory[0].pairs_of_species))]
        # &#39;FC&#39; = Fixed Cutoff (default)
        # &#39;SANN&#39; = Solid Angle Nearest Neighbors
        self.nearest_neighbors_method = &#39;FC&#39;

    def set_cutoff(self, s1, s2, rcut, mirror=True):
        &#34;&#34;&#34;
        Set the nearest-neighbor cutoff for the pair of species (s1, s2).
        The cutoff of the mirror pair (s2, s1) is set automatically if the `mirror` 
        parameter is True (default).        

        Parameters
        ----------
        s1 : str
            Symbol of the first species.
        s2 : str
            Symbol of the second species.
        rcut : float
            Value of the cutoff for the pair (s1,s2).
        mirror : bool, optional
            Set the cutoff for the mirror pair (s2,s1). The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        pairs = self.trajectory[0].pairs_of_species
        idx_12 = pairs.index((s1, s2))
        self.cutoffs[idx_12] = rcut
        if mirror:
            idx_21 = pairs.index((s2, s1))
            self.cutoffs[idx_21] = rcut

    # TODO: define self.neighbors as an attribute for the class
    def nearest_neighbors(self, method=&#39;FC&#39;):
        &#34;&#34;&#34;
        Compute the nearest neighbors of particles in group=0 using one of the
        following methods:
        - &#34;Fixed cutoff&#34; (method=&#39;FC&#39;): uses the partial radial distribution functions 
          to compute the cutoffs between each possible pair of species (s1, s2) ;
        - &#34;Solid-Angle based Nearest Neighbors&#34; (method=&#39;SANN&#39;): see  
           van Meel et al. (https://doi.org/10.1063/1.4729313) ;        

        Parameters
        ----------
        method : str, optional
            Method to identify nearest neighbors. Must be &#39;FC&#39; or &#39;SANN&#39;.
            The default is &#39;FC&#39;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # indices
        idx_0 = self.dump(&#39;index&#39;, 0)
        idx_1 = self.dump(&#39;index&#39;, 1)
        idx_all = self.trajectory.get_property(&#39;index&#39;)
        # species
        spe_0 = self.dump(&#39;species_id&#39;, 0)
        spe_1 = self.dump(&#39;species_id&#39;, 1)
        pairs = numpy.asarray(self.trajectory[0].pairs_of_species_id)
        # positions
        pos_0 = self.dump(&#39;position&#39;, 0)
        pos_1 = self.dump(&#39;position&#39;, 1)
        pos_all = self.trajectory.get_property(&#39;position&#39;)
        # compute all/missing cutoffs
        if None in self.cutoffs:
            self._compute_cutoffs()
        cutoffs = numpy.array(self.cutoffs)
        # boundaries
        n_frames = len(self.groups[0])
        box = self.trajectory[0].cell.side
        # list of neighbors
        self.neighbors = [[] for n in range(n_frames)]

        # Fixed cutoff
        if method == &#39;FC&#39;:
            for n in range(n_frames):
                for i in range(len(idx_0[n])):
                    neigh_i = compute.nearest_neighbors(idx_0[n][i], idx_1[n],
                                                        pos_0[n][i], pos_1[n].T,
                                                        spe_0[n][i], spe_1[n],
                                                        pairs, box, cutoffs)
                    neigh_i = neigh_i[neigh_i &gt;= 0]
                    self.neighbors[n].append(neigh_i)

        #  Solid Angle Nearest Neighbors (SANN)
        #   This will find all neighbors of `i`
        #   (including particles not in group=1)
        if method == &#39;SANN&#39;:
            # scaling factor for first guess as trying neighbors
            rmax = 1.5 * numpy.max(cutoffs)
            for n in range(n_frames):
                for i in range(len(idx_0[n])):
                    neigh_i = compute.sann(pos_0[n][i], pos_all[n].T,
                                           idx_0[n][i], idx_all[n], idx_1[n],
                                           rmax, box)
                    neigh_i = neigh_i[neigh_i &gt;= 0]
                    self.neighbors[n].append(neigh_i)

    # TODO: if fixed-cutoff method, let the user choose `dr`
    def _compute_cutoffs(self):
        from .gr import RadialDescriptor
        pairs = self.trajectory[0].pairs_of_species
        for pair in pairs:
            if self.cutoffs[pairs.index(pair)] is None:
                s1, s2 = pair
                # use the smallest side of the smallest box in case of
                #  non-constant volume trajectory
                sides = numpy.array(self.trajectory.get_property(&#39;cell.side&#39;))
                L = numpy.min(sides)
                bounds = (0.0, L / 2)
                descriptor = RadialDescriptor(self.trajectory, dr=0.1, bounds=bounds)
                descriptor.add_filter(&#34;species == &#39;{}&#39;&#34;.format(s1), group=0)
                descriptor.add_filter(&#34;species == &#39;{}&#39;&#34;.format(s2), group=1)
                descriptor.compute()
                # grid and average descriptor
                r = descriptor.grid
                h_12 = descriptor.average
                # normalized g(r)
                g_12 = descriptor.normalize(h_12, method=&#34;gr&#34;)
                # find the first minimum of g_12(r)
                first_max = numpy.argmax(g_12)
                first_min = numpy.argmin(g_12[first_max:]) + first_max
                rcut = r[first_min]
                # set the cutoff
                self.set_cutoff(s1, s2, rcut)


class DummyDescriptor(StructuralDescriptor):

    name = &#39;dummy&#39;
    symbol = &#39;dm&#39;

    def __init__(self):
        self.grid = [0, 1]
        self.features = None

    def normalize(self, dist):
        return dist * (1.0 / numpy.sum(dist))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="partycls.descriptor.descriptor.AngularStructuralDescriptor"><code class="flex name class">
<span>class <span class="ident">AngularStructuralDescriptor</span></span>
<span>(</span><span>trajectory)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for angular structural descriptors.</p>
<p>See the parent class for more details.</p>
<p>Descriptors that exploit angular correlations and require nearest-neighbors information
will inherit of this class. Two methods to identify nearest-neighbors are available:
- "Fixed cutoff" (symbol: 'FC'): uses the partial radial distribution functions to compute
the cutoffs between each possible pair of species (s1, s2) ;
- "Solid-Angle based Nearest Neighbors" (symbol: 'SANN'): see van Meel et al. (<a href="https://doi.org/10.1063/1.4729313">https://doi.org/10.1063/1.4729313</a>)</p>
<p>The nearest-neighbors method can be changed by modifying the attribute <code>nearest_neighbors_method</code>
to 'FC' (default) or 'SANN'.</p>
<p>When using the 'FC' method, it is also possible to specify the cutoffs manually
for a pair of species (s1, s2) by using the method <code>set_cutoff</code>. The cutoffs
that were not set manually will be computed automatically.</p>
<h2 id="parameters">Parameters</h2>
<p>trajectory : str or an instance of <code>Trajectory</code>.
Trajectory on which the structural descriptor will be computed.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>cutoffs</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>List of cutoff distances to identify the nearest neighbors using
the fixed-cutoff ('FC') method.</dd>
<dt><strong><code>nearest_neighbors_method</code></strong> :&ensp;<code>str</code>, default<code>: 'FC'</code></dt>
<dd>Nearest neighbor method, 'FC' or 'SANN'.</dd>
<dt><strong><code>neighbors</code></strong> :&ensp;<code>list</code></dt>
<dd>Lists of nearest neighbors for all the particles in group=0. Empty by
default and filled when calling the method <code>nearest_neighbors</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AngularStructuralDescriptor(StructuralDescriptor):
    &#34;&#34;&#34;
    Base class for angular structural descriptors.
    
    See the parent class for more details.
    
    Descriptors that exploit angular correlations and require nearest-neighbors information 
    will inherit of this class. Two methods to identify nearest-neighbors are available:
    - &#34;Fixed cutoff&#34; (symbol: &#39;FC&#39;): uses the partial radial distribution functions to compute
      the cutoffs between each possible pair of species (s1, s2) ;
    - &#34;Solid-Angle based Nearest Neighbors&#34; (symbol: &#39;SANN&#39;): see van Meel et al. (https://doi.org/10.1063/1.4729313)
    
    The nearest-neighbors method can be changed by modifying the attribute `nearest_neighbors_method`
    to &#39;FC&#39; (default) or &#39;SANN&#39;.
    
    When using the &#39;FC&#39; method, it is also possible to specify the cutoffs manually
    for a pair of species (s1, s2) by using the method `set_cutoff`. The cutoffs
    that were not set manually will be computed automatically.
    
    Parameters
    ----------
    
    trajectory : str or an instance of `Trajectory`.
        Trajectory on which the structural descriptor will be computed.
    
    Attributes
    ----------
    
    cutoffs : list of float
        List of cutoff distances to identify the nearest neighbors using
        the fixed-cutoff (&#39;FC&#39;) method.
        
    nearest_neighbors_method : str, default: &#39;FC&#39;
        Nearest neighbor method, &#39;FC&#39; or &#39;SANN&#39;.
        
    neighbors : list
        Lists of nearest neighbors for all the particles in group=0. Empty by
        default and filled when calling the method `nearest_neighbors`.
    &#34;&#34;&#34;

    def __init__(self, trajectory):
        StructuralDescriptor.__init__(self, trajectory)
        self.cutoffs = [None for n in range(len(self.trajectory[0].pairs_of_species))]
        # &#39;FC&#39; = Fixed Cutoff (default)
        # &#39;SANN&#39; = Solid Angle Nearest Neighbors
        self.nearest_neighbors_method = &#39;FC&#39;

    def set_cutoff(self, s1, s2, rcut, mirror=True):
        &#34;&#34;&#34;
        Set the nearest-neighbor cutoff for the pair of species (s1, s2).
        The cutoff of the mirror pair (s2, s1) is set automatically if the `mirror` 
        parameter is True (default).        

        Parameters
        ----------
        s1 : str
            Symbol of the first species.
        s2 : str
            Symbol of the second species.
        rcut : float
            Value of the cutoff for the pair (s1,s2).
        mirror : bool, optional
            Set the cutoff for the mirror pair (s2,s1). The default is True.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        pairs = self.trajectory[0].pairs_of_species
        idx_12 = pairs.index((s1, s2))
        self.cutoffs[idx_12] = rcut
        if mirror:
            idx_21 = pairs.index((s2, s1))
            self.cutoffs[idx_21] = rcut

    # TODO: define self.neighbors as an attribute for the class
    def nearest_neighbors(self, method=&#39;FC&#39;):
        &#34;&#34;&#34;
        Compute the nearest neighbors of particles in group=0 using one of the
        following methods:
        - &#34;Fixed cutoff&#34; (method=&#39;FC&#39;): uses the partial radial distribution functions 
          to compute the cutoffs between each possible pair of species (s1, s2) ;
        - &#34;Solid-Angle based Nearest Neighbors&#34; (method=&#39;SANN&#39;): see  
           van Meel et al. (https://doi.org/10.1063/1.4729313) ;        

        Parameters
        ----------
        method : str, optional
            Method to identify nearest neighbors. Must be &#39;FC&#39; or &#39;SANN&#39;.
            The default is &#39;FC&#39;.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # indices
        idx_0 = self.dump(&#39;index&#39;, 0)
        idx_1 = self.dump(&#39;index&#39;, 1)
        idx_all = self.trajectory.get_property(&#39;index&#39;)
        # species
        spe_0 = self.dump(&#39;species_id&#39;, 0)
        spe_1 = self.dump(&#39;species_id&#39;, 1)
        pairs = numpy.asarray(self.trajectory[0].pairs_of_species_id)
        # positions
        pos_0 = self.dump(&#39;position&#39;, 0)
        pos_1 = self.dump(&#39;position&#39;, 1)
        pos_all = self.trajectory.get_property(&#39;position&#39;)
        # compute all/missing cutoffs
        if None in self.cutoffs:
            self._compute_cutoffs()
        cutoffs = numpy.array(self.cutoffs)
        # boundaries
        n_frames = len(self.groups[0])
        box = self.trajectory[0].cell.side
        # list of neighbors
        self.neighbors = [[] for n in range(n_frames)]

        # Fixed cutoff
        if method == &#39;FC&#39;:
            for n in range(n_frames):
                for i in range(len(idx_0[n])):
                    neigh_i = compute.nearest_neighbors(idx_0[n][i], idx_1[n],
                                                        pos_0[n][i], pos_1[n].T,
                                                        spe_0[n][i], spe_1[n],
                                                        pairs, box, cutoffs)
                    neigh_i = neigh_i[neigh_i &gt;= 0]
                    self.neighbors[n].append(neigh_i)

        #  Solid Angle Nearest Neighbors (SANN)
        #   This will find all neighbors of `i`
        #   (including particles not in group=1)
        if method == &#39;SANN&#39;:
            # scaling factor for first guess as trying neighbors
            rmax = 1.5 * numpy.max(cutoffs)
            for n in range(n_frames):
                for i in range(len(idx_0[n])):
                    neigh_i = compute.sann(pos_0[n][i], pos_all[n].T,
                                           idx_0[n][i], idx_all[n], idx_1[n],
                                           rmax, box)
                    neigh_i = neigh_i[neigh_i &gt;= 0]
                    self.neighbors[n].append(neigh_i)

    # TODO: if fixed-cutoff method, let the user choose `dr`
    def _compute_cutoffs(self):
        from .gr import RadialDescriptor
        pairs = self.trajectory[0].pairs_of_species
        for pair in pairs:
            if self.cutoffs[pairs.index(pair)] is None:
                s1, s2 = pair
                # use the smallest side of the smallest box in case of
                #  non-constant volume trajectory
                sides = numpy.array(self.trajectory.get_property(&#39;cell.side&#39;))
                L = numpy.min(sides)
                bounds = (0.0, L / 2)
                descriptor = RadialDescriptor(self.trajectory, dr=0.1, bounds=bounds)
                descriptor.add_filter(&#34;species == &#39;{}&#39;&#34;.format(s1), group=0)
                descriptor.add_filter(&#34;species == &#39;{}&#39;&#34;.format(s2), group=1)
                descriptor.compute()
                # grid and average descriptor
                r = descriptor.grid
                h_12 = descriptor.average
                # normalized g(r)
                g_12 = descriptor.normalize(h_12, method=&#34;gr&#34;)
                # find the first minimum of g_12(r)
                first_max = numpy.argmax(g_12)
                first_min = numpy.argmin(g_12[first_max:]) + first_max
                rcut = r[first_min]
                # set the cutoff
                self.set_cutoff(s1, s2, rcut)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="partycls.descriptor.descriptor.StructuralDescriptor" href="#partycls.descriptor.descriptor.StructuralDescriptor">StructuralDescriptor</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="partycls.descriptor.ba.BondAngleDescriptor" href="ba.html#partycls.descriptor.ba.BondAngleDescriptor">BondAngleDescriptor</a></li>
<li><a title="partycls.descriptor.bo.BondOrientationalDescriptor" href="bo.html#partycls.descriptor.bo.BondOrientationalDescriptor">BondOrientationalDescriptor</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="partycls.descriptor.descriptor.AngularStructuralDescriptor.nearest_neighbors"><code class="name flex">
<span>def <span class="ident">nearest_neighbors</span></span>(<span>self, method='FC')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the nearest neighbors of particles in group=0 using one of the
following methods:
- "Fixed cutoff" (method='FC'): uses the partial radial distribution functions
to compute the cutoffs between each possible pair of species (s1, s2) ;
- "Solid-Angle based Nearest Neighbors" (method='SANN'): see<br>
van Meel et al. (<a href="https://doi.org/10.1063/1.4729313">https://doi.org/10.1063/1.4729313</a>) ;
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method to identify nearest neighbors. Must be 'FC' or 'SANN'.
The default is 'FC'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def nearest_neighbors(self, method=&#39;FC&#39;):
    &#34;&#34;&#34;
    Compute the nearest neighbors of particles in group=0 using one of the
    following methods:
    - &#34;Fixed cutoff&#34; (method=&#39;FC&#39;): uses the partial radial distribution functions 
      to compute the cutoffs between each possible pair of species (s1, s2) ;
    - &#34;Solid-Angle based Nearest Neighbors&#34; (method=&#39;SANN&#39;): see  
       van Meel et al. (https://doi.org/10.1063/1.4729313) ;        

    Parameters
    ----------
    method : str, optional
        Method to identify nearest neighbors. Must be &#39;FC&#39; or &#39;SANN&#39;.
        The default is &#39;FC&#39;.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    # indices
    idx_0 = self.dump(&#39;index&#39;, 0)
    idx_1 = self.dump(&#39;index&#39;, 1)
    idx_all = self.trajectory.get_property(&#39;index&#39;)
    # species
    spe_0 = self.dump(&#39;species_id&#39;, 0)
    spe_1 = self.dump(&#39;species_id&#39;, 1)
    pairs = numpy.asarray(self.trajectory[0].pairs_of_species_id)
    # positions
    pos_0 = self.dump(&#39;position&#39;, 0)
    pos_1 = self.dump(&#39;position&#39;, 1)
    pos_all = self.trajectory.get_property(&#39;position&#39;)
    # compute all/missing cutoffs
    if None in self.cutoffs:
        self._compute_cutoffs()
    cutoffs = numpy.array(self.cutoffs)
    # boundaries
    n_frames = len(self.groups[0])
    box = self.trajectory[0].cell.side
    # list of neighbors
    self.neighbors = [[] for n in range(n_frames)]

    # Fixed cutoff
    if method == &#39;FC&#39;:
        for n in range(n_frames):
            for i in range(len(idx_0[n])):
                neigh_i = compute.nearest_neighbors(idx_0[n][i], idx_1[n],
                                                    pos_0[n][i], pos_1[n].T,
                                                    spe_0[n][i], spe_1[n],
                                                    pairs, box, cutoffs)
                neigh_i = neigh_i[neigh_i &gt;= 0]
                self.neighbors[n].append(neigh_i)

    #  Solid Angle Nearest Neighbors (SANN)
    #   This will find all neighbors of `i`
    #   (including particles not in group=1)
    if method == &#39;SANN&#39;:
        # scaling factor for first guess as trying neighbors
        rmax = 1.5 * numpy.max(cutoffs)
        for n in range(n_frames):
            for i in range(len(idx_0[n])):
                neigh_i = compute.sann(pos_0[n][i], pos_all[n].T,
                                       idx_0[n][i], idx_all[n], idx_1[n],
                                       rmax, box)
                neigh_i = neigh_i[neigh_i &gt;= 0]
                self.neighbors[n].append(neigh_i)</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.AngularStructuralDescriptor.set_cutoff"><code class="name flex">
<span>def <span class="ident">set_cutoff</span></span>(<span>self, s1, s2, rcut, mirror=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the nearest-neighbor cutoff for the pair of species (s1, s2).
The cutoff of the mirror pair (s2, s1) is set automatically if the <code>mirror</code>
parameter is True (default).
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>s1</code></strong> :&ensp;<code>str</code></dt>
<dd>Symbol of the first species.</dd>
<dt><strong><code>s2</code></strong> :&ensp;<code>str</code></dt>
<dd>Symbol of the second species.</dd>
<dt><strong><code>rcut</code></strong> :&ensp;<code>float</code></dt>
<dd>Value of the cutoff for the pair (s1,s2).</dd>
<dt><strong><code>mirror</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Set the cutoff for the mirror pair (s2,s1). The default is True.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_cutoff(self, s1, s2, rcut, mirror=True):
    &#34;&#34;&#34;
    Set the nearest-neighbor cutoff for the pair of species (s1, s2).
    The cutoff of the mirror pair (s2, s1) is set automatically if the `mirror` 
    parameter is True (default).        

    Parameters
    ----------
    s1 : str
        Symbol of the first species.
    s2 : str
        Symbol of the second species.
    rcut : float
        Value of the cutoff for the pair (s1,s2).
    mirror : bool, optional
        Set the cutoff for the mirror pair (s2,s1). The default is True.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    pairs = self.trajectory[0].pairs_of_species
    idx_12 = pairs.index((s1, s2))
    self.cutoffs[idx_12] = rcut
    if mirror:
        idx_21 = pairs.index((s2, s1))
        self.cutoffs[idx_21] = rcut</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="partycls.descriptor.descriptor.StructuralDescriptor" href="#partycls.descriptor.descriptor.StructuralDescriptor">StructuralDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.add_filter" href="#partycls.descriptor.descriptor.StructuralDescriptor.add_filter">add_filter</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.average" href="#partycls.descriptor.descriptor.StructuralDescriptor.average">average</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.clear_all_filters" href="#partycls.descriptor.descriptor.StructuralDescriptor.clear_all_filters">clear_all_filters</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.clear_filters" href="#partycls.descriptor.descriptor.StructuralDescriptor.clear_filters">clear_filters</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.dump" href="#partycls.descriptor.descriptor.StructuralDescriptor.dump">dump</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.get_group_property" href="#partycls.descriptor.descriptor.StructuralDescriptor.get_group_property">get_group_property</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.group_fraction" href="#partycls.descriptor.descriptor.StructuralDescriptor.group_fraction">group_fraction</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.group_size" href="#partycls.descriptor.descriptor.StructuralDescriptor.group_size">group_size</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.n_features" href="#partycls.descriptor.descriptor.StructuralDescriptor.n_features">n_features</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.normalize" href="#partycls.descriptor.descriptor.StructuralDescriptor.normalize">normalize</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.size" href="#partycls.descriptor.descriptor.StructuralDescriptor.size">size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="partycls.descriptor.descriptor.DummyDescriptor"><code class="flex name class">
<span>class <span class="ident">DummyDescriptor</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for structural descriptors.</p>
<p>The descriptor is calculated for the provided trajectory <code>trajectory</code>. This can be:
- an object implementing the <code>Trajectory</code> interface ;
- the path to a trajectory file in a format recognized by partyclsl ;</p>
<p>A structural descriptor S(x) is a collection of N individual empirical correlation
functions {s_i(x)} at the particle level, defined over a grid {x_j} of M features.
These are stored in the <code>features</code> array as a matrix usually refered to as the "data set":</p>
<p>s_0(x_0) s_0(x_1) &hellip; s_0(x_M)
s_1(x_0) s_1(x_1) &hellip; s_1(x_M)
&hellip;
&hellip;
&hellip;
s_N(x_0) s_N(x_1) &hellip; s_N(x_M)</p>
<p>The <code>features</code> array is None by default and is computed only when the <code>compute()</code> method is called.</p>
<p>The correlations can be calculated between two arbitrary subsets of particles called "groups":
- group 0 is the main group, i.e. particles for which the correlations are being calculated ;
- group 1 is the secondary group, i.e. particles that are being considered when calculating the correlations ;
These groups are formed by adding filters on particles' properties (species, radius, position, etc.).</p>
<h2 id="parameters">Parameters</h2>
<p>trajectory : str or an instance of <code>Trajectory</code>.
Trajectory on which the structural descriptor will be computed.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>Trajectory</code></dt>
<dd>Trajectory on which the structural descriptor will be computed.</dd>
<dt><strong><code>active_filters</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>All the active filters on both groups prior to the computation of the
descriptor.</dd>
<dt><strong><code>dimension</code></strong> :&ensp;<code>int</code></dt>
<dd>Spatial dimension of the descriptor (2 or 3).</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>array</code></dt>
<dd>Grid over which the structural features will be computed.</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of all the structural features for the particles in group=0 in
accordance with the defined filters (if any). This attribute is
initialized when the method <code>compute</code> is called (default value is None).</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Composition of the groups: groups[0] and groups[1] contain lists of all
the <code>Particle</code> objects in groups 0 and 1 respectively. Each element of
the tuple is a list of <code>Particle</code> in <code>trajectory</code>, e.g. groups[0][0] is
the list of all the particles in the first frame of <code>trajectory</code> that
belong to group=0.</dd>
</dl>
<h2 id="examples">Examples:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; D = StructuralDescriptor('trajectory.xyz')
&gt;&gt;&gt; D.add_filter(&quot;species == 'A'&quot;, group=0)
&gt;&gt;&gt; D.add_filter(&quot;species == 'B'&quot;, group=1)
&gt;&gt;&gt; D.active_filters
[(&quot;particle.species == 'A'&quot;, 0), (&quot;particle.species == 'B'&quot;, 1)]
&gt;&gt;&gt; D.clear_filters(0)
&gt;&gt;&gt; D.active_filters
[(&quot;particle.species == 'B'&quot;, 1)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DummyDescriptor(StructuralDescriptor):

    name = &#39;dummy&#39;
    symbol = &#39;dm&#39;

    def __init__(self):
        self.grid = [0, 1]
        self.features = None

    def normalize(self, dist):
        return dist * (1.0 / numpy.sum(dist))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="partycls.descriptor.descriptor.StructuralDescriptor" href="#partycls.descriptor.descriptor.StructuralDescriptor">StructuralDescriptor</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="partycls.descriptor.descriptor.DummyDescriptor.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="partycls.descriptor.descriptor.DummyDescriptor.symbol"><code class="name">var <span class="ident">symbol</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="partycls.descriptor.descriptor.StructuralDescriptor" href="#partycls.descriptor.descriptor.StructuralDescriptor">StructuralDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.add_filter" href="#partycls.descriptor.descriptor.StructuralDescriptor.add_filter">add_filter</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.average" href="#partycls.descriptor.descriptor.StructuralDescriptor.average">average</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.clear_all_filters" href="#partycls.descriptor.descriptor.StructuralDescriptor.clear_all_filters">clear_all_filters</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.clear_filters" href="#partycls.descriptor.descriptor.StructuralDescriptor.clear_filters">clear_filters</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.dump" href="#partycls.descriptor.descriptor.StructuralDescriptor.dump">dump</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.get_group_property" href="#partycls.descriptor.descriptor.StructuralDescriptor.get_group_property">get_group_property</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.group_fraction" href="#partycls.descriptor.descriptor.StructuralDescriptor.group_fraction">group_fraction</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.group_size" href="#partycls.descriptor.descriptor.StructuralDescriptor.group_size">group_size</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.n_features" href="#partycls.descriptor.descriptor.StructuralDescriptor.n_features">n_features</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.normalize" href="#partycls.descriptor.descriptor.StructuralDescriptor.normalize">normalize</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.size" href="#partycls.descriptor.descriptor.StructuralDescriptor.size">size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor"><code class="flex name class">
<span>class <span class="ident">StructuralDescriptor</span></span>
<span>(</span><span>trajectory)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for structural descriptors.</p>
<p>The descriptor is calculated for the provided trajectory <code>trajectory</code>. This can be:
- an object implementing the <code>Trajectory</code> interface ;
- the path to a trajectory file in a format recognized by partyclsl ;</p>
<p>A structural descriptor S(x) is a collection of N individual empirical correlation
functions {s_i(x)} at the particle level, defined over a grid {x_j} of M features.
These are stored in the <code>features</code> array as a matrix usually refered to as the "data set":</p>
<p>s_0(x_0) s_0(x_1) &hellip; s_0(x_M)
s_1(x_0) s_1(x_1) &hellip; s_1(x_M)
&hellip;
&hellip;
&hellip;
s_N(x_0) s_N(x_1) &hellip; s_N(x_M)</p>
<p>The <code>features</code> array is None by default and is computed only when the <code>compute()</code> method is called.</p>
<p>The correlations can be calculated between two arbitrary subsets of particles called "groups":
- group 0 is the main group, i.e. particles for which the correlations are being calculated ;
- group 1 is the secondary group, i.e. particles that are being considered when calculating the correlations ;
These groups are formed by adding filters on particles' properties (species, radius, position, etc.).</p>
<h2 id="parameters">Parameters</h2>
<p>trajectory : str or an instance of <code>Trajectory</code>.
Trajectory on which the structural descriptor will be computed.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>trajectory</code></strong> :&ensp;<code>Trajectory</code></dt>
<dd>Trajectory on which the structural descriptor will be computed.</dd>
<dt><strong><code>active_filters</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>All the active filters on both groups prior to the computation of the
descriptor.</dd>
<dt><strong><code>dimension</code></strong> :&ensp;<code>int</code></dt>
<dd>Spatial dimension of the descriptor (2 or 3).</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>array</code></dt>
<dd>Grid over which the structural features will be computed.</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Array of all the structural features for the particles in group=0 in
accordance with the defined filters (if any). This attribute is
initialized when the method <code>compute</code> is called (default value is None).</dd>
<dt><strong><code>groups</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Composition of the groups: groups[0] and groups[1] contain lists of all
the <code>Particle</code> objects in groups 0 and 1 respectively. Each element of
the tuple is a list of <code>Particle</code> in <code>trajectory</code>, e.g. groups[0][0] is
the list of all the particles in the first frame of <code>trajectory</code> that
belong to group=0.</dd>
</dl>
<h2 id="examples">Examples:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; D = StructuralDescriptor('trajectory.xyz')
&gt;&gt;&gt; D.add_filter(&quot;species == 'A'&quot;, group=0)
&gt;&gt;&gt; D.add_filter(&quot;species == 'B'&quot;, group=1)
&gt;&gt;&gt; D.active_filters
[(&quot;particle.species == 'A'&quot;, 0), (&quot;particle.species == 'B'&quot;, 1)]
&gt;&gt;&gt; D.clear_filters(0)
&gt;&gt;&gt; D.active_filters
[(&quot;particle.species == 'B'&quot;, 1)]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StructuralDescriptor:
    &#34;&#34;&#34;
    Base class for structural descriptors.
    
    The descriptor is calculated for the provided trajectory `trajectory`. This can be:
    - an object implementing the `Trajectory` interface ;
    - the path to a trajectory file in a format recognized by partyclsl ;
    
    A structural descriptor S(x) is a collection of N individual empirical correlation 
    functions {s_i(x)} at the particle level, defined over a grid {x_j} of M features.
    These are stored in the `features` array as a matrix usually refered to as the &#34;data set&#34;:
    
    s_0(x_0) s_0(x_1) ... s_0(x_M)
    s_1(x_0) s_1(x_1) ... s_1(x_M)
    ...      ...          ...
    s_N(x_0) s_N(x_1) ... s_N(x_M)
    
    The `features` array is None by default and is computed only when the `compute()` method is called.
    
    The correlations can be calculated between two arbitrary subsets of particles called &#34;groups&#34;:
    - group 0 is the main group, i.e. particles for which the correlations are being calculated ;
    - group 1 is the secondary group, i.e. particles that are being considered when calculating the correlations ;
    These groups are formed by adding filters on particles&#39; properties (species, radius, position, etc.).
    
    Parameters
    ----------
    
    trajectory : str or an instance of `Trajectory`.
        Trajectory on which the structural descriptor will be computed.
    
    Attributes
    ----------
    
    trajectory : Trajectory
        Trajectory on which the structural descriptor will be computed.
        
    active_filters : list of str
        All the active filters on both groups prior to the computation of the
        descriptor.
        
    dimension : int
        Spatial dimension of the descriptor (2 or 3).
        
    grid : array
        Grid over which the structural features will be computed.
        
    features : ndarray
        Array of all the structural features for the particles in group=0 in
        accordance with the defined filters (if any). This attribute is 
        initialized when the method `compute` is called (default value is None).
        
    groups : tuple
        Composition of the groups: groups[0] and groups[1] contain lists of all
        the `Particle` objects in groups 0 and 1 respectively. Each element of 
        the tuple is a list of `Particle` in `trajectory`, e.g. groups[0][0] is 
        the list of all the particles in the first frame of `trajectory` that 
        belong to group=0.
    
    Examples:
    ---------
    
    &gt;&gt;&gt; D = StructuralDescriptor(&#39;trajectory.xyz&#39;)
    &gt;&gt;&gt; D.add_filter(&#34;species == &#39;A&#39;&#34;, group=0)
    &gt;&gt;&gt; D.add_filter(&#34;species == &#39;B&#39;&#34;, group=1)
    &gt;&gt;&gt; D.active_filters
    [(&#34;particle.species == &#39;A&#39;&#34;, 0), (&#34;particle.species == &#39;B&#39;&#34;, 1)]
    &gt;&gt;&gt; D.clear_filters(0)
    &gt;&gt;&gt; D.active_filters
    [(&#34;particle.species == &#39;B&#39;&#34;, 1)]
    &#34;&#34;&#34;

    def __init__(self, trajectory):
        # Trajectory
        # TODO: we can&#39;t change format or backend when passing a string
        if isinstance(trajectory, str):
            self.trajectory = Trajectory(trajectory)
        else:
            self.trajectory = trajectory
        # Default: consider all particles for the correlation
        self.groups = ([], [])
        self._group_init(0)
        self._group_init(1)
        # Active filters (none by default)
        self.active_filters = []
        # Dimension is guessed from the first frame of the trajectory
        self.dimension = self.trajectory[0].n_dimensions
        # Features
        #  default is None (when the object is created)
        #  correctly assigned when is method compute() is called
        self.grid = None
        self.features = None

    def __str__(self):
        rep = &#39;Descriptor(name=&#34;{}&#34;, dimension={}, filters={})&#39;
        return rep.format(self.name, self.dimension, self.active_filters)

    def __repr__(self):
        return self.__str__()

    def _group_init(self, group):
        &#34;&#34;&#34;
        Initialize the group `group` with all the particles by default.
        &#34;&#34;&#34;
        self.groups[group].clear()
        for system in self.trajectory:
            frame = []
            for particle in system.particle:
                frame.append(particle)
            self.groups[group].append(frame.copy())

    def add_filter(self, condition, group=0):
        &#34;&#34;&#34;
        Add a filter on the group (0 or 1) to select the subset of particles
        that respects the provided condition.

        Parameters
        ----------
        condition : str
            The condition should have the following format:
    
            &lt;attribute&gt; _operator_ &lt;value&gt;
            
            where:
            - &lt;attribute&gt; is a particle property (accepts aliases) ;
            - _operator_ is a logical operator (&lt;, &lt;=, ==, &gt;=, &gt;) ;
            - &lt;value&gt; is the corresponding value of &lt;attribute&gt; with the proper type ;
        
        group : int, optional
            Index of the group to which the filter must be applied.
            The default is 0.

        Returns
        -------
        None.
        
        Examples:
        ---------
        &gt;&gt;&gt; S = StructuralDescriptor(&#39;trajectory.xyz&#39;)
        &gt;&gt;&gt; S.add_filter(&#34;particle.radius &lt; 0.5&#34;)
        &gt;&gt;&gt; S.add_filter(&#34;species == &#39;A&#39;&#34;, group=1)
        &gt;&gt;&gt; S.add_filter(&#34;x &lt; 0&#34;, group=0) # particles on the left side of the box
      
        &#34;&#34;&#34;
        condition = standardize_condition(condition)
        self.active_filters.append((condition, group))
        # Iterate over frames
        for frame in self.groups[group]:
            to_remove = []
            # First find particles to remove from the current frame
            for particle in frame:
                if not(eval(condition)):
                    to_remove.append(particle)
            # Actually remove them
            for p_to_rem in to_remove:
                frame.remove(p_to_rem)
        self._sanity_checks()

    def clear_filters(self, group=0):
        &#34;&#34;&#34;
        Clear all active filters on `group`.
        All particles are included again in `group`.        

        Parameters
        ----------
        group : int, optional
            Index of the group on which to clear the filters. The default is 0.

        Returns
        -------
        None.

        &#34;&#34;&#34;
        # Reset `group` with all the particles
        self._group_init(group)
        # Update the `active_filters` list
        for fltr in self.active_filters:
            if fltr[1] == group:
                self.active_filters.remove(fltr)

    def clear_all_filters(self):
        &#34;&#34;&#34;
        Clear all active filters in both groups.
        All particles are included in both groups again.        

        Returns
        -------
        None.

        &#34;&#34;&#34;
        self._group_init(0)
        self._group_init(1)
        self.active_filters = []

    def group_size(self, group):
        &#34;&#34;&#34;
        Return the number of particles in `group`.
        &#34;&#34;&#34;
        N = 0
        for frame in self.groups[group]:
            N += len(frame)
        return N

    def get_group_property(self, what, group):
        &#34;&#34;&#34;
        Return a list of numpy arrays with the properties of the particles in
        group `group`. The list size is the number of systems in the 
        trajectory.

        Parameters
        ----------
        what : str
            Requested particle property. 
            
            `what` must be a particle property or an alias.
            
            The following particle aliases are accepted:
            - &#39;position&#39;: &#39;particle.position&#39;
            - &#39;pos&#39;: &#39;particle.position&#39;
            - &#39;position[0]&#39;: &#39;particle.position[0]&#39;, 
            - &#39;pos[0]&#39;: &#39;particle.position[0]&#39;
            - &#39;x&#39;: &#39;particle.position[0]&#39;
            - &#39;position[1]&#39;: &#39;particle.position[1]&#39;,
            - &#39;pos[1]&#39;: &#39;particle.position[1]&#39;
            - &#39;y&#39;: &#39;particle.position[1]&#39;
            - &#39;position[2]&#39;: &#39;particle.position[2]&#39;
            - &#39;pos[2]&#39;: &#39;particle.position[2]&#39;
            - &#39;z&#39;: &#39;particle.position[2]&#39;
            - &#39;species&#39;: &#39;particle.species&#39;
            - &#39;spe&#39;: &#39;particle.species&#39;
            - &#39;label&#39;: &#39;particle.label&#39;
            - &#39;index&#39;: &#39;particle.index&#39;
            - &#39;mass&#39;: &#39;particle.mass&#39;
            - &#39;radius&#39;: &#39;particle.radius&#39;

        Returns
        -------
        to_dump : list
            List of the requested particle property with length equal to the 
            number of frames in the trajectory. Each element of the list is a
            numpy.ndarray of the requested particle property.
            
        Examples
        --------
        &gt;&gt;&gt; traj = Trajectory(&#39;trajectory.xyz&#39;)
        &gt;&gt;&gt; D = StructuralDescriptor(traj)
        &gt;&gt;&gt; D.get_group_property(&#39;position&#39;, 0)
        &gt;&gt;&gt; D.get_group_property(&#39;x&#39;, 1)
        &gt;&gt;&gt; D.get_group_property(&#39;energy&#39;, 0)
        
        &#34;&#34;&#34;
        if what in aliases:
            what = aliases[what]
        if what.startswith(&#39;particle&#39;):
            what = what.split(&#39;.&#39;)[-1]
        to_dump = []
        for frame in self.groups[group]:
            to_dump_frame = []
            for particle in frame:
                to_dump_frame.append(eval(&#39;particle.{}&#39;.format(what)))
            to_dump.append(numpy.array(to_dump_frame))
        return to_dump

    def dump(self, what, group):
        &#34;&#34;&#34;
        Alias for the method get_group_property.
        &#34;&#34;&#34;
        return self.get_group_property(what, group)

    def group_fraction(self, group):
        &#34;&#34;&#34;
        Return the fraction of particles inside `group` over the whole trajectory.
        &#34;&#34;&#34;
        N_group = self.group_size(group)
        N_tot = numpy.sum([len(sys.particle) for sys in self.trajectory])
        return N_group / N_tot

    @property
    def size(self):
        &#34;&#34;&#34;
        Total number of particles in the descriptor (i.e. in group=0).
        &#34;&#34;&#34;
        return sum([len(frame) for frame in self.groups[0]])

    @property
    def n_features(self):
        &#34;&#34;&#34;
        Number of features of the descriptor.
        &#34;&#34;&#34;
        return len(self.grid)

    @property
    def average(self):
        &#34;&#34;&#34;
        Average feature vector of the descriptor.
        &#34;&#34;&#34;
        return numpy.mean(self.features, axis=0)

    def compute(self):
        pass

    def normalize(self, dist):
        &#34;&#34;&#34;
        Generic normalization function for child classes. Returns the input
        distribution unchanged.
        &#34;&#34;&#34;
        return dist

    def _sanity_checks(self):
        assert (self.group_size(0) &gt; 0 and self.group_size(1) &gt; 0), &#39;groups cannot be empty.&#39;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="partycls.descriptor.descriptor.AngularStructuralDescriptor" href="#partycls.descriptor.descriptor.AngularStructuralDescriptor">AngularStructuralDescriptor</a></li>
<li><a title="partycls.descriptor.descriptor.DummyDescriptor" href="#partycls.descriptor.descriptor.DummyDescriptor">DummyDescriptor</a></li>
<li><a title="partycls.descriptor.dscribe.DscribeDescriptor" href="dscribe.html#partycls.descriptor.dscribe.DscribeDescriptor">DscribeDescriptor</a></li>
<li><a title="partycls.descriptor.gr.RadialDescriptor" href="gr.html#partycls.descriptor.gr.RadialDescriptor">RadialDescriptor</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.average"><code class="name">var <span class="ident">average</span></code></dt>
<dd>
<div class="desc"><p>Average feature vector of the descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def average(self):
    &#34;&#34;&#34;
    Average feature vector of the descriptor.
    &#34;&#34;&#34;
    return numpy.mean(self.features, axis=0)</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.n_features"><code class="name">var <span class="ident">n_features</span></code></dt>
<dd>
<div class="desc"><p>Number of features of the descriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_features(self):
    &#34;&#34;&#34;
    Number of features of the descriptor.
    &#34;&#34;&#34;
    return len(self.grid)</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.size"><code class="name">var <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Total number of particles in the descriptor (i.e. in group=0).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34;
    Total number of particles in the descriptor (i.e. in group=0).
    &#34;&#34;&#34;
    return sum([len(frame) for frame in self.groups[0]])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.add_filter"><code class="name flex">
<span>def <span class="ident">add_filter</span></span>(<span>self, condition, group=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a filter on the group (0 or 1) to select the subset of particles
that respects the provided condition.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>condition</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The condition should have the following format:</p>
<p><attribute> <em>operator</em> <value></p>
<p>where:
- <attribute> is a particle property (accepts aliases) ;
- <em>operator</em> is a logical operator (&lt;, &lt;=, ==, &gt;=, &gt;) ;
- <value> is the corresponding value of <attribute> with the proper type ;</p>
</dd>
<dt><strong><code>group</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Index of the group to which the filter must be applied.
The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p>
<h2 id="examples">Examples:</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; S = StructuralDescriptor('trajectory.xyz')
&gt;&gt;&gt; S.add_filter(&quot;particle.radius &lt; 0.5&quot;)
&gt;&gt;&gt; S.add_filter(&quot;species == 'A'&quot;, group=1)
&gt;&gt;&gt; S.add_filter(&quot;x &lt; 0&quot;, group=0) # particles on the left side of the box
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_filter(self, condition, group=0):
    &#34;&#34;&#34;
    Add a filter on the group (0 or 1) to select the subset of particles
    that respects the provided condition.

    Parameters
    ----------
    condition : str
        The condition should have the following format:

        &lt;attribute&gt; _operator_ &lt;value&gt;
        
        where:
        - &lt;attribute&gt; is a particle property (accepts aliases) ;
        - _operator_ is a logical operator (&lt;, &lt;=, ==, &gt;=, &gt;) ;
        - &lt;value&gt; is the corresponding value of &lt;attribute&gt; with the proper type ;
    
    group : int, optional
        Index of the group to which the filter must be applied.
        The default is 0.

    Returns
    -------
    None.
    
    Examples:
    ---------
    &gt;&gt;&gt; S = StructuralDescriptor(&#39;trajectory.xyz&#39;)
    &gt;&gt;&gt; S.add_filter(&#34;particle.radius &lt; 0.5&#34;)
    &gt;&gt;&gt; S.add_filter(&#34;species == &#39;A&#39;&#34;, group=1)
    &gt;&gt;&gt; S.add_filter(&#34;x &lt; 0&#34;, group=0) # particles on the left side of the box
  
    &#34;&#34;&#34;
    condition = standardize_condition(condition)
    self.active_filters.append((condition, group))
    # Iterate over frames
    for frame in self.groups[group]:
        to_remove = []
        # First find particles to remove from the current frame
        for particle in frame:
            if not(eval(condition)):
                to_remove.append(particle)
        # Actually remove them
        for p_to_rem in to_remove:
            frame.remove(p_to_rem)
    self._sanity_checks()</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.clear_all_filters"><code class="name flex">
<span>def <span class="ident">clear_all_filters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all active filters in both groups.
All particles are included in both groups again.
</p>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_all_filters(self):
    &#34;&#34;&#34;
    Clear all active filters in both groups.
    All particles are included in both groups again.        

    Returns
    -------
    None.

    &#34;&#34;&#34;
    self._group_init(0)
    self._group_init(1)
    self.active_filters = []</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.clear_filters"><code class="name flex">
<span>def <span class="ident">clear_filters</span></span>(<span>self, group=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Clear all active filters on <code>group</code>.
All particles are included again in <code>group</code>.
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>group</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Index of the group on which to clear the filters. The default is 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_filters(self, group=0):
    &#34;&#34;&#34;
    Clear all active filters on `group`.
    All particles are included again in `group`.        

    Parameters
    ----------
    group : int, optional
        Index of the group on which to clear the filters. The default is 0.

    Returns
    -------
    None.

    &#34;&#34;&#34;
    # Reset `group` with all the particles
    self._group_init(group)
    # Update the `active_filters` list
    for fltr in self.active_filters:
        if fltr[1] == group:
            self.active_filters.remove(fltr)</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.compute"><code class="name flex">
<span>def <span class="ident">compute</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute(self):
    pass</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self, what, group)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for the method get_group_property.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self, what, group):
    &#34;&#34;&#34;
    Alias for the method get_group_property.
    &#34;&#34;&#34;
    return self.get_group_property(what, group)</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.get_group_property"><code class="name flex">
<span>def <span class="ident">get_group_property</span></span>(<span>self, what, group)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of numpy arrays with the properties of the particles in
group <code>group</code>. The list size is the number of systems in the
trajectory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>what</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Requested particle property. </p>
<p><code>what</code> must be a particle property or an alias.</p>
<p>The following particle aliases are accepted:
- 'position': 'particle.position'
- 'pos': 'particle.position'
- 'position[0]': 'particle.position[0]',
- 'pos[0]': 'particle.position[0]'
- 'x': 'particle.position[0]'
- 'position[1]': 'particle.position[1]',
- 'pos[1]': 'particle.position[1]'
- 'y': 'particle.position[1]'
- 'position[2]': 'particle.position[2]'
- 'pos[2]': 'particle.position[2]'
- 'z': 'particle.position[2]'
- 'species': 'particle.species'
- 'spe': 'particle.species'
- 'label': 'particle.label'
- 'index': 'particle.index'
- 'mass': 'particle.mass'
- 'radius': 'particle.radius'</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>to_dump</code></strong> :&ensp;<code>list</code></dt>
<dd>List of the requested particle property with length equal to the
number of frames in the trajectory. Each element of the list is a
numpy.ndarray of the requested particle property.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; traj = Trajectory('trajectory.xyz')
&gt;&gt;&gt; D = StructuralDescriptor(traj)
&gt;&gt;&gt; D.get_group_property('position', 0)
&gt;&gt;&gt; D.get_group_property('x', 1)
&gt;&gt;&gt; D.get_group_property('energy', 0)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_group_property(self, what, group):
    &#34;&#34;&#34;
    Return a list of numpy arrays with the properties of the particles in
    group `group`. The list size is the number of systems in the 
    trajectory.

    Parameters
    ----------
    what : str
        Requested particle property. 
        
        `what` must be a particle property or an alias.
        
        The following particle aliases are accepted:
        - &#39;position&#39;: &#39;particle.position&#39;
        - &#39;pos&#39;: &#39;particle.position&#39;
        - &#39;position[0]&#39;: &#39;particle.position[0]&#39;, 
        - &#39;pos[0]&#39;: &#39;particle.position[0]&#39;
        - &#39;x&#39;: &#39;particle.position[0]&#39;
        - &#39;position[1]&#39;: &#39;particle.position[1]&#39;,
        - &#39;pos[1]&#39;: &#39;particle.position[1]&#39;
        - &#39;y&#39;: &#39;particle.position[1]&#39;
        - &#39;position[2]&#39;: &#39;particle.position[2]&#39;
        - &#39;pos[2]&#39;: &#39;particle.position[2]&#39;
        - &#39;z&#39;: &#39;particle.position[2]&#39;
        - &#39;species&#39;: &#39;particle.species&#39;
        - &#39;spe&#39;: &#39;particle.species&#39;
        - &#39;label&#39;: &#39;particle.label&#39;
        - &#39;index&#39;: &#39;particle.index&#39;
        - &#39;mass&#39;: &#39;particle.mass&#39;
        - &#39;radius&#39;: &#39;particle.radius&#39;

    Returns
    -------
    to_dump : list
        List of the requested particle property with length equal to the 
        number of frames in the trajectory. Each element of the list is a
        numpy.ndarray of the requested particle property.
        
    Examples
    --------
    &gt;&gt;&gt; traj = Trajectory(&#39;trajectory.xyz&#39;)
    &gt;&gt;&gt; D = StructuralDescriptor(traj)
    &gt;&gt;&gt; D.get_group_property(&#39;position&#39;, 0)
    &gt;&gt;&gt; D.get_group_property(&#39;x&#39;, 1)
    &gt;&gt;&gt; D.get_group_property(&#39;energy&#39;, 0)
    
    &#34;&#34;&#34;
    if what in aliases:
        what = aliases[what]
    if what.startswith(&#39;particle&#39;):
        what = what.split(&#39;.&#39;)[-1]
    to_dump = []
    for frame in self.groups[group]:
        to_dump_frame = []
        for particle in frame:
            to_dump_frame.append(eval(&#39;particle.{}&#39;.format(what)))
        to_dump.append(numpy.array(to_dump_frame))
    return to_dump</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.group_fraction"><code class="name flex">
<span>def <span class="ident">group_fraction</span></span>(<span>self, group)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the fraction of particles inside <code>group</code> over the whole trajectory.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_fraction(self, group):
    &#34;&#34;&#34;
    Return the fraction of particles inside `group` over the whole trajectory.
    &#34;&#34;&#34;
    N_group = self.group_size(group)
    N_tot = numpy.sum([len(sys.particle) for sys in self.trajectory])
    return N_group / N_tot</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.group_size"><code class="name flex">
<span>def <span class="ident">group_size</span></span>(<span>self, group)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of particles in <code>group</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_size(self, group):
    &#34;&#34;&#34;
    Return the number of particles in `group`.
    &#34;&#34;&#34;
    N = 0
    for frame in self.groups[group]:
        N += len(frame)
    return N</code></pre>
</details>
</dd>
<dt id="partycls.descriptor.descriptor.StructuralDescriptor.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, dist)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic normalization function for child classes. Returns the input
distribution unchanged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self, dist):
    &#34;&#34;&#34;
    Generic normalization function for child classes. Returns the input
    distribution unchanged.
    &#34;&#34;&#34;
    return dist</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="https://htmlpreview.github.io/?https://github.com/jorisparet/partycls/blob/master/docs/partycls/index.html">
<img class="logo" src="https://raw.githubusercontent.com/jorisparet/partycls/jupyter-book/logo/logo.svg" alt="Logo">
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder=" Search docs" aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<!-- joris: before <h1>Index</h1> -->
<h1><a href="index.html">Index</a></h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="partycls.descriptor" href="index.html">partycls.descriptor</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="partycls.descriptor.descriptor.AngularStructuralDescriptor" href="#partycls.descriptor.descriptor.AngularStructuralDescriptor">AngularStructuralDescriptor</a></code></h4>
<ul class="">
<li><code><a title="partycls.descriptor.descriptor.AngularStructuralDescriptor.nearest_neighbors" href="#partycls.descriptor.descriptor.AngularStructuralDescriptor.nearest_neighbors">nearest_neighbors</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.AngularStructuralDescriptor.set_cutoff" href="#partycls.descriptor.descriptor.AngularStructuralDescriptor.set_cutoff">set_cutoff</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="partycls.descriptor.descriptor.DummyDescriptor" href="#partycls.descriptor.descriptor.DummyDescriptor">DummyDescriptor</a></code></h4>
<ul class="">
<li><code><a title="partycls.descriptor.descriptor.DummyDescriptor.name" href="#partycls.descriptor.descriptor.DummyDescriptor.name">name</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.DummyDescriptor.symbol" href="#partycls.descriptor.descriptor.DummyDescriptor.symbol">symbol</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="partycls.descriptor.descriptor.StructuralDescriptor" href="#partycls.descriptor.descriptor.StructuralDescriptor">StructuralDescriptor</a></code></h4>
<ul class="two-column">
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.add_filter" href="#partycls.descriptor.descriptor.StructuralDescriptor.add_filter">add_filter</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.average" href="#partycls.descriptor.descriptor.StructuralDescriptor.average">average</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.clear_all_filters" href="#partycls.descriptor.descriptor.StructuralDescriptor.clear_all_filters">clear_all_filters</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.clear_filters" href="#partycls.descriptor.descriptor.StructuralDescriptor.clear_filters">clear_filters</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.compute" href="#partycls.descriptor.descriptor.StructuralDescriptor.compute">compute</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.dump" href="#partycls.descriptor.descriptor.StructuralDescriptor.dump">dump</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.get_group_property" href="#partycls.descriptor.descriptor.StructuralDescriptor.get_group_property">get_group_property</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.group_fraction" href="#partycls.descriptor.descriptor.StructuralDescriptor.group_fraction">group_fraction</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.group_size" href="#partycls.descriptor.descriptor.StructuralDescriptor.group_size">group_size</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.n_features" href="#partycls.descriptor.descriptor.StructuralDescriptor.n_features">n_features</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.normalize" href="#partycls.descriptor.descriptor.StructuralDescriptor.normalize">normalize</a></code></li>
<li><code><a title="partycls.descriptor.descriptor.StructuralDescriptor.size" href="#partycls.descriptor.descriptor.StructuralDescriptor.size">size</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
By Joris Paret and Daniele Coslovich.  Copyright 2021.
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>